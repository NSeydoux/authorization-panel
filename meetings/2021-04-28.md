# 2021-04-28 Solid Authorization

* [Meeting](https://meet.jit.si/solid-authorization)
* [Chat](https://gitter.im/solid/authorization-panel?at=6088092ac1a9210b3c23a55a)
* [Notes](https://hackmd.io/mFgvpYMZR7Co_DIDgUaNwA)

## Agenda

* Minutes https://github.com/solid/authorization-panel/pull/207
* Cleanup minutes: standard filename and extension https://github.com/solid/authorization-panel/pull/208
* Add issue template https://github.com/solid/authorization-panel/pull/205
* Commit [PR 201](https://github.com/solid/authorization-panel/pull/201)?
* AnyOf, AllOf, etc...


## Present

* Justin Bingham
* Eric Prud'hommeaux
* Henry Story
* Matthieu Bosquet
* Sarven Capadisli


## Minutes

1. Commited Meeting Cleanups
2. Appropve minutes from 207 without the ACP code discused in the last few minutes in the last call
3. Elf Accept changed and then Commit on PR 205
4. Merged 201


## ACP apply policy algorithm


```typescript
/**
 * # The apply policy algorithm
 *
 * A policy is applied if:
 * - At least one matcher it uses matches the given context; and
 * - All the conditions it defines are satisfied.
 *
 * Policy conditions behave like intersection, union and exclusion operators. In
 * order to be satisfied:
 * - allOf requires all of its matchers to match the given context;
 * - anyOf requires one of its matchers to match the given context;
 * - noneOf requires none of its matchers to match the given context.
 *
 * Note: Given that the noneOf condition excludes matches, a policy without a
 * satisfied allOf or anyOf condition never applies.
 *
 * @param policy The policy to evaluate
 * @param context The context in which the policy is evaluated
 * @returns True if the policy applies, false otherwise
 */
export function applyPolicy(policy: IPolicy, context: IContext): boolean {
  const matchContext = (matcher: IMatcher) => {
    return matcher.match(context);
  };

  // A policy without positive match doesn't apply
  if (policy.allOf.length + policy.anyOf.length === 0) {
    return false;
  }

  return (
    (policy.allOf.length === 0 || policy.allOf.every(matchContext)) &&
    (policy.anyOf.length === 0 || policy.anyOf.some(matchContext)) &&
    (policy.noneOf.length === 0 || !policy.noneOf.some(matchContext))
  );
}
```

ACP all of is an intersection of sets.

Relation from LDPR to Access control (via header)

```turtle
<mydoc> acp:accessControl <mydoc.acp#> .
```

The ACR doc contains a policy X mandating access over the resource controlled by <#>.
```Turtle
<#> acp:apply ex:PolicyX .
```

The ACR doc contains another policy Y mandating access over itself (<>).
```Turtle
<#>
    acp:access ex:PolicyY .
    acp:applyProtected ex:ProtectedAccessControl1 .
```

Exploring 1 predicate (infinite recursion):
```turtle
ex:resource1 acp:access ex:acr1 .
ex:acr1 acp:access ex:acr2 .
ex:acr2 acp:access ex:acr3 .
```

Epistemology (what you know) vs ontology (how tings are).

Henry: this looks very much like `:authorizes`?


Here, the Policy X will apply if all the matchers are satisfied in the current context. A context would be the description of a resource access.


```turtle
prefix ex: <https://example.com/>

ex:PolicyX
    acp:allow acl:Read ; # would only having acp:allow acl:Read imply anything other than Read? Why would acp:deny be necessary?
    acp:deny acl:Write ;
    acp:allOf ex:AgentMatcher1, ex:IssuerMatcher1, ex:TimeMatcher1, ex:CredentialIssueTimeMatcher1 .

ex:AgentMatcher1
    acp:agent ex:Bob, ex:Alice .

ex:IssuerMatcher1
    acp:issuer ex:IdP1 .

ex:TimeMatcher1
    acp:time [
    some owl time range e.g. sunday 10am to 2pm
    ]
```



```turtle
ex:ResourceAccess1
    acp:time "2021-04-26T15:30:00Z" ;
    acp:agent ex:Bob ;
    acp:issuer ex:IdP1 ;
    acp:resource ex:MyResource1 .
```




=> with this context Bob is allowed ACL read.

ACP some of is the union of the sets described by all matchers.


```turtle
prefix ex: <https://example.com/>

ex:PolicyY
    acp:allow acl:Read ;
    acp:someOf ex:AgentMatcherFriends1, ex:AgentMatcherFamily1 .

ex:AgentMatcherFriends1
    acp:agent ex:Henry, ex:Jay .

ex:AgentMatcherFamily1
    acp:agent ex:Bob, ex:Alice .
```

This Policy will apply if you are any of the agents defined by AgentMatcherFriends1 and AgentMatcherFamily1.


ACP none of is an exclusion over a set.


Access to a resource based on credentials. For example over 18.

```turtle
ex:resource
ex:PolicyVC
    acp:allow acl:Read ;
    acp:allOf ex:VCMatcher1 .

ex:VCMatcher1
    rdfs:label "Over 18 VC Matcher" ;
    acp:vc ex:over18 .
```

Diagnosis > Conditions > Observations

Access inheritance via specific paths.

Condition 456 -> Observation 789 -> 


Henry: How do you describe sets of resources that have set of properties in addition to describing agents that have sets of properties? And how do you describe the relationships between those?

Sarven: How does the shapetree work through HTTP resources where the target of a request is a resource. It is a document with a body... How does shapetree work in context of a resource targeted?

The chain of how information is preserved (host a medical image XRay is an ldp resource is this shapetree the shapetree has resources to other resources)

## Actions

* Elf to Accept suggestions and commit [PR 205](https://github.com/solid/authorization-panel/pull/205) - done
